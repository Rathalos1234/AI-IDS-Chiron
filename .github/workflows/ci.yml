name: CI

on:
  pull_request:
    branches: [ Combined, main ]
  push:
    branches: [ Combined, main, develop, develop-redundant ]
  schedule:
    - cron: "0 9 * * *"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  PIP_DISABLE_PIP_VERSION_CHECK: "1"
  PYTHONUNBUFFERED: "1"
  PYTHONDONTWRITEBYTECODE: "1"

jobs:
  # AI test jobs (fast for PR gate, full for scheduled/push)
  fast:
    name: Lint + Unit (PR gate)
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: "pip"
          cache-dependency-path: |
            AI-IDS/requirements.txt
            AI-IDS/requirements-dev.txt
      - name: Upgrade pip
        run: python -m pip install --upgrade pip wheel
      - name: Install deps (runtime + test/linters)
        run: pip install -r AI-IDS/requirements.txt pytest ruff mypy
      - name: Make scripts executable
        run: chmod +x AI-IDS/scripts/test_fast.sh AI-IDS/scripts/test_full.sh
      - name: Run fast gate
        run: bash AI-IDS/scripts/test_fast.sh
        env:
          LINT_STRICT: "1"

  full:
    name: Unit + Integration (+ perf)
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: "pip"
          cache-dependency-path: |
            AI-IDS/requirements.txt
            AI-IDS/requirements-dev.txt
      - name: Upgrade pip
        run: python -m pip install --upgrade pip wheel
      - name: Install deps
        run: pip install -r AI-IDS/requirements.txt pytest ruff mypy
      - name: Make scripts executable
        run: chmod +x AI-IDS/scripts/test_full.sh
      - name: Run full suite
        run: bash AI-IDS/scripts/test_full.sh
      - name: Append perf snapshot to job summary
        if: always()
        run: |
          echo "### Perf snapshot (10k rows)" >> $GITHUB_STEP_SUMMARY
          if [ -f sprint_artifacts/pytest_perf.txt ]; then
            tail -n 50 sprint_artifacts/pytest_perf.txt >> $GITHUB_STEP_SUMMARY
          else
            echo "No perf output found (skipped or failed)" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload sprint artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sprint_artifacts
          path: sprint_artifacts/**
          if-no-files-found: ignore

  setup:
    name: Setup (cache deps)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Chiron/web
    outputs:
      node-cache-hit: ${{ steps.cache-npm.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v4
      - name: Use Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            Chiron/web/package-lock.json
            Chiron/web/package.json
      - name: Cache node_modules
        id: cache-npm
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            Chiron/web/node_modules
          key: ${{ runner.os }}-node20-${{ hashFiles('Chiron/web/package-lock.json', 'Chiron/web/package.json') }}
      - name: Install deps
        working-directory: Chiron/web
        if: steps.cache-npm.outputs.cache-hit != 'true'
        run: |
          if [ -f Chiron/web/package-lock.json ]; then
            npm ci
          else
            npm install
          fi

  # lint:
  #   name: Lint
  #   needs: setup
  #   runs-on: ubuntu-latest
  #   defaults: { run: { working-directory: Chiron/web } }
  #   steps:
  #     - uses: actions/checkout@v4
  #     - uses: actions/setup-node@v4
  #       with: { node-version: 20, cache: npm, cache-dependency-path: Chiron/web/package-lock.json }
  #     - run: npm ci
  #     - run: npm run lint

  typecheck:
    name: TypeScript
    needs: setup
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: Chiron/web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            Chiron/web/package-lock.json
            Chiron/web/package.json
      - run: |
          if [ -f Chiron/web/package-lock.json ]; then
            npm ci
          else
            npm install
          fi
      - run: npm run typecheck

  unit:
    name: Unit tests
    needs: [setup, typecheck]
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: Chiron/web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            Chiron/web/package-lock.json
            Chiron/web/package.json
      - run: |
          if [ -f Chiron/web/package-lock.json ]; then
            npm ci
          else
            npm install
          fi
      - run: npm run coverage
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: Chiron/web/coverage

  build:
    name: Build (PR artifact)
    needs: [unit]
    runs-on: ubuntu-latest
    env:
      VITE_BASE_PATH: /Chiron/web   # adjust if your GH Pages path differs
    defaults: { run: { working-directory: Chiron/web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            Chiron/web/package-lock.json
            Chiron/web/package.json
      - run: |
          if [ -f Chiron/web/package-lock.json ]; then
            npm ci
          else
            npm install
          fi
      - run: npm run build
      - name: Upload build
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: Chiron/web/dist

  # # Docker image build & push (only on push to main)
  # build-and-push:
  #   name: Build and push Docker image to GHCR
  #   needs: [build]
  #   if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
  #   runs-on: ubuntu-latest
  #   outputs:
  #     image_tag: ${{ steps.meta.outputs.tags }}
  #     image_repository: ${{ steps.repo_lower.outputs.repository }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Compute lowercase image name
  #       id: repo_lower
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const owner = context.repo.owner.toLowerCase();
  #           const repo = context.repo.repo.toLowerCase();
  #           core.setOutput('repository', `${owner}/${repo}`);

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Log in to GitHub Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Extract metadata
  #       id: meta
  #       uses: docker/metadata-action@v5
  #       with:
  #         images: ghcr.io/${{ steps.repo_lower.outputs.repository }}
  #         tags: |
  #           type=sha,prefix=main-
  #           type=raw,value=latest

  #     - name: Build and push Docker image
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: .
  #         push: true
  #         tags: ${{ steps.meta.outputs.tags }}
  #         labels: ${{ steps.meta.outputs.labels }}
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max
  #         build-args: |
  #           PY_VER=3.10

  # # Deploy to production server via SSH (only on push to main)
  # deploy-production:
  #   name: Deploy to production
  #   needs: [build-and-push]
  #   if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
  #   runs-on: ubuntu-latest
  #   env:
  #     DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
  #     DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
  #     SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  #     GHCR_PAT: ${{ secrets.GHCR_PAT }}
  #     DEPLOY_REPO_TOKEN: ${{ secrets.DEPLOY_REPO_TOKEN }}
  #   steps:
  #     - name: Deploy via SSH
  #       if: ${{ env.DEPLOY_HOST != '' && env.DEPLOY_USER != '' && env.SSH_PRIVATE_KEY != '' }}
  #       uses: appleboy/ssh-action@v1.0.3
  #       env:
  #         IMAGE_REPOSITORY: ${{ needs.build-and-push.outputs.image_repository }}
  #         BRANCH_NAME: ${{ github.ref_name }}
  #         GHCR_PAT: ${{ env.GHCR_PAT }}
  #         DEPLOY_REPO_TOKEN: ${{ env.DEPLOY_REPO_TOKEN }}
  #         REPO_OWNER: ${{ github.repository_owner }}
  #       with:
  #         host: ${{ env.DEPLOY_HOST }}
  #         username: ${{ env.DEPLOY_USER }}
  #         key: ${{ env.SSH_PRIVATE_KEY }}
  #         envs: GHCR_PAT,DEPLOY_REPO_TOKEN,IMAGE_REPOSITORY,BRANCH_NAME,REPO_OWNER
  #         script: |
  #           set -euo pipefail

  #           if [ -z "${IMAGE_REPOSITORY:-}" ]; then
  #             echo "IMAGE_REPOSITORY output is not available"
  #             exit 1
  #           fi

  #           if [ -z "${GHCR_PAT:-}" ]; then
  #             echo "GHCR_PAT secret is not configured"
  #             exit 1
  #           fi

  #           # Navigate to deployment directory
  #           cd /opt/ai-ids || exit 1

  #           if ! command -v docker >/dev/null 2>&1; then
  #             echo "Docker is not installed on the remote host"
  #             exit 1
  #           fi

  #           if ! docker compose version >/dev/null 2>&1; then
  #             echo "Docker Compose plugin is not installed on the remote host"
  #             exit 1
  #           fi

  #           # Ensure the repository is present
  #           if [ -z "${DEPLOY_REPO_TOKEN:-}" ]; then
  #             echo "DEPLOY_REPO_TOKEN secret is not configured"
  #             exit 1
  #           fi

  #           TOKEN_REMOTE="https://${DEPLOY_REPO_TOKEN}@github.com/${IMAGE_REPOSITORY}.git"
  #           CLEAN_REMOTE="https://github.com/${IMAGE_REPOSITORY}.git"
  #           BRANCH="${BRANCH_NAME:-main}"

  #           if [ ! -d .git ]; then
  #             echo "Cloning repository..."
  #             git clone "${TOKEN_REMOTE}" .
  #             git checkout "${BRANCH}"
  #           else
  #             echo "Refreshing repository..."
  #             git remote set-url origin "${TOKEN_REMOTE}"
  #             git fetch --prune
  #             git checkout "${BRANCH}"
  #             git reset --hard "origin/${BRANCH}"
  #           fi

  #           git remote set-url origin "${CLEAN_REMOTE}"
  #           unset DEPLOY_REPO_TOKEN || true

  #           # Ensure required directories and files exist for bind mounts
  #           mkdir -p data logs models ssl ui/dist

  #           # Provide docker-compose with the image reference
  #           if [ -f .env ]; then
  #             sed -i '/^GITHUB_REPOSITORY=/d' .env
  #           fi
  #           echo "GITHUB_REPOSITORY=${IMAGE_REPOSITORY}" >> .env

  #           # Authenticate with GHCR before pulling images
  #           GHCR_USER="${REPO_OWNER:-${IMAGE_REPOSITORY%%/*}}"
  #           echo "Logging into ghcr.io as ${GHCR_USER}"
  #           echo "${GHCR_PAT}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin
  #           unset GHCR_PAT || true

  #           # Pull latest image
  #           docker pull ghcr.io/${IMAGE_REPOSITORY}:latest

  #           # Stop and remove old containers
  #           docker compose down || true

  #           # Start new containers
  #           docker compose up -d

  #           # Verify deployment
  #           sleep 5
  #           if docker compose ps | grep -q "Up"; then
  #             echo "Deployment successful"
  #           else
  #             echo "Deployment failed - containers not running"
  #             exit 1
  #           fi
            
  #           # Clean up old images
  #           docker image prune -f

  #     - name: Notify deployment status
  #       if: always()
  #       run: |
  #         if [ "${{ job.status }}" == "success" ]; then
  #           echo "✅ Deployment to production completed successfully"
  #         else
  #           echo "❌ Deployment to production failed"
  #         fi