name: CI

on:
  pull_request:
    branches: [ Dev, main ]
    paths:
      - "web/**"
      - ".github/workflows/**"
  push:
    branches: [ Dev ]
    paths:
      - "web/**"
      - ".github/workflows/**"

jobs:
  setup:
    name: Setup (cache deps)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    outputs:
      node-cache-hit: ${{ steps.cache-npm.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v4
      - name: Use Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: web/package-lock.json
      - name: Cache node_modules
        id: cache-npm
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            web/node_modules
          key: ${{ runner.os }}-node20-${{ hashFiles('web/package-lock.json') }}
      - name: Install deps
        if: steps.cache-npm.outputs.cache-hit != 'true'
        run: npm ci

  # lint:
  #   name: Lint
  #   needs: setup
  #   runs-on: ubuntu-latest
  #   defaults: { run: { working-directory: web } }
  #   steps:
  #     - uses: actions/checkout@v4
  #     - uses: actions/setup-node@v4
  #       with: { node-version: 20, cache: npm, cache-dependency-path: web/package-lock.json }
  #     - run: npm ci
  #     - run: npm run lint

  typecheck:
    name: TypeScript
    needs: setup
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: npm, cache-dependency-path: web/package-lock.json }
      - run: npm ci
      - run: npm run typecheck

  unit:
    name: Unit tests
    needs: [setup, typecheck]
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: npm, cache-dependency-path: web/package-lock.json }
      - run: npm ci
      - run: npm run coverage
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: web/coverage

  build:
    name: Build (PR artifact)
    needs: [unit]
    runs-on: ubuntu-latest
    env:
      VITE_BASE_PATH: /web   # adjust if your GH Pages path differs
    defaults: { run: { working-directory: web } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: npm, cache-dependency-path: web/package-lock.json }
      - run: npm ci
      - run: npm run build
      - name: Upload build
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: web/dist

  # Docker image build & push (only on push to main)
  build-and-push:
    name: Build and push Docker image to GHCR
    needs: [build]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_repository: ${{ steps.repo_lower.outputs.repository }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Compute lowercase image name
        id: repo_lower
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner.toLowerCase();
            const repo = context.repo.repo.toLowerCase();
            core.setOutput('repository', `${owner}/${repo}`);

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo_lower.outputs.repository }}
          tags: |
            type=sha,prefix=main-
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            PY_VER=3.10

  # Deploy to production server via SSH (only on push to main)
  deploy-production:
    name: Deploy to production
    needs: [build-and-push]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://${{ secrets.DEPLOY_HOST }}
    steps:
      - name: Deploy via SSH
        if: ${{ secrets.DEPLOY_HOST != '' && secrets.DEPLOY_USER != '' && secrets.SSH_PRIVATE_KEY != '' }}
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_REPOSITORY: ${{ needs.build-and-push.outputs.image_repository }}
          BRANCH_NAME: ${{ github.ref_name }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          DEPLOY_REPO_TOKEN: ${{ secrets.DEPLOY_REPO_TOKEN }}
          REPO_OWNER: ${{ github.repository_owner }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: GHCR_PAT,DEPLOY_REPO_TOKEN,IMAGE_REPOSITORY,BRANCH_NAME,REPO_OWNER
          script: |
            set -euo pipefail

            if [ -z "${IMAGE_REPOSITORY:-}" ]; then
              echo "IMAGE_REPOSITORY output is not available"
              exit 1
            fi

            if [ -z "${GHCR_PAT:-}" ]; then
              echo "GHCR_PAT secret is not configured"
              exit 1
            fi

            # Navigate to deployment directory
            cd /opt/ai-ids || exit 1

            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker is not installed on the remote host"
              exit 1
            fi

            if ! docker compose version >/dev/null 2>&1; then
              echo "Docker Compose plugin is not installed on the remote host"
              exit 1
            fi

            # Ensure the repository is present
            if [ -z "${DEPLOY_REPO_TOKEN:-}" ]; then
              echo "DEPLOY_REPO_TOKEN secret is not configured"
              exit 1
            fi

            TOKEN_REMOTE="https://${DEPLOY_REPO_TOKEN}@github.com/${IMAGE_REPOSITORY}.git"
            CLEAN_REMOTE="https://github.com/${IMAGE_REPOSITORY}.git"
            BRANCH="${BRANCH_NAME:-main}"

            if [ ! -d .git ]; then
              echo "Cloning repository..."
              git clone "${TOKEN_REMOTE}" .
              git checkout "${BRANCH}"
            else
              echo "Refreshing repository..."
              git remote set-url origin "${TOKEN_REMOTE}"
              git fetch --prune
              git checkout "${BRANCH}"
              git reset --hard "origin/${BRANCH}"
            fi

            git remote set-url origin "${CLEAN_REMOTE}"
            unset DEPLOY_REPO_TOKEN || true

            # Ensure required directories and files exist for bind mounts
            mkdir -p data logs models ssl ui/dist

            # Provide docker-compose with the image reference
            if [ -f .env ]; then
              sed -i '/^GITHUB_REPOSITORY=/d' .env
            fi
            echo "GITHUB_REPOSITORY=${IMAGE_REPOSITORY}" >> .env

            # Authenticate with GHCR before pulling images
            GHCR_USER="${REPO_OWNER:-${IMAGE_REPOSITORY%%/*}}"
            echo "Logging into ghcr.io as ${GHCR_USER}"
            echo "${GHCR_PAT}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin
            unset GHCR_PAT || true

            # Pull latest image
            docker pull ghcr.io/${IMAGE_REPOSITORY}:latest

            # Stop and remove old containers
            docker compose down || true

            # Start new containers
            docker compose up -d

            # Verify deployment
            sleep 5
            if docker compose ps | grep -q "Up"; then
              echo "Deployment successful"
            else
              echo "Deployment failed - containers not running"
              exit 1
            fi
            
            # Clean up old images
            docker image prune -f

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment to production completed successfully"
          else
            echo "❌ Deployment to production failed"
          fi
